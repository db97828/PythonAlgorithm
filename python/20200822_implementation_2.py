"""
작성일: 2020-08-22
==============================================================================
문제: 게임 개발
1. 현재 위치에서 현재 방향ㅇ르 기준으로 왼쪽 방향(반 시계 방향으로 90도 회전할 방향)부터
차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음
왼쪽으로 한 칸을 전진한다. 오니쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만
수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을
유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수
없는 경우에는 움직임을 멈춘다.

캐릭터가 방문한 칸의 수를 출력한다.
==============================================================================
소요 시간: 00분
"""
n, m = map(int, input().split())

d = [[0] * m for _ in range(n)]
x, y, direction = map(int, input().split())
d[x][y] = 1

array = []
for i in range(n):
    array.append(list(map(int, input().split())))

#북 동 남 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def turn_left():
    global direction
    #북0 동1 남2 서3
    #현재 방향에서 왼쪽으로 돌수록 1씩 감소
    direction -= 1
    #북에서 돌면 서로
    if direction == -1:
        direction = 3

count = 1
turn_time = 0
while True:
    turn_left()
    nx = x + dx[direction]
    ny = y + dy[direction]
    #갔던곳도 아니고 바다도 아니면 가기
    if d[nx][ny] == 0 and array[nx][ny] == 0:
        d[nx][ny] = 1
        x = nx
        y = ny
        count += 1
        turn_time = 0
        continue
    else:
        #못 가면 돌기
        turn_time += 1
    #네쪽 다 갈 수 없으면
    if turn_time == 4:
        nx = x - dx[direction]
        ny = y - dy[direction]
        #뒤로 갈 수 있으면
        if array[nx][ny] == 0:
            x = nx
            y = ny
        #뒤로 못가면
        else:
            break
        turn_time = 0

print(count)

"""
접근법: 
==============================================================================
다른 해결 방식: 다른 해결 방법
"""
"""
==============================================================================
개선점: 개선할 수 있는 부분
==============================================================================
노트:
d = [[0] * m for _ in range(n)]
#배열 d를 0으로 m개만큼 n번씩 채움 [0, 0, ..., 0//총 m개], ...[0, 0, ..., 0]//총 n개
array.append(list(map(int, input().split()))) //array에 추가

"""